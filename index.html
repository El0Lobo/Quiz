<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pepsi's Quiz</title>

  <!-- Styles -->
  <link rel="stylesheet" href="quiz.css" />
  <style>
    /* Visual cues for selection & feedback */
    .answers .opt { cursor: pointer; user-select: none; display:flex; align-items:center; gap:.5rem; padding:.4rem .6rem; border-radius:.6rem; }
    .answers .opt.picked { outline: 2px solid currentColor; }
    .answers .opt.hidden { display: none; }
    .answers .opt.correct { background: rgba(50,205,50,.12); box-shadow: inset 0 0 0 2px rgba(50,205,50,.35); }
    .answers .opt.correct.missed { opacity: .55; } 
    .answers .opt.wrong { background: rgba(220,20,60,.12); box-shadow: inset 0 0 0 2px rgba(220,20,60,.35); }
    button[disabled] { opacity:.5; cursor:not-allowed; }
  </style>

  <!-- Load your question sets BEFORE the main quiz script -->
  <script src="questions.js"></script>
  <script src="Spectroscopy.js"></script>


  <!-- Gather inline sets into a single place the app can read -->
  <script>
    window.__QUIZ_SETS__ = [];
    window.__QUIZ_SET_NAMES__ = [];
    if (Array.isArray(window.questions))  { window.__QUIZ_SETS__.push(window.questions);  window.__QUIZ_SET_NAMES__.push('questions.js'); }
    if (Array.isArray(window.questions2)) { window.__QUIZ_SETS__.push(window.questions2); window.__QUIZ_SET_NAMES__.push('questions2.js'); }
  </script>

  <!-- MathJax for TeX + MathML (use $...$ or <math>...</math>) -->
  <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
      svg: { fontCache: 'global' }
    };
  </script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-svg.js"></script>
</head>

<body>
    <img
    id="flaus"
    class="anim-image"
    src="Flaus.png"
    alt="Click me for a surprise animation"
    title="Click me!"
    draggable="false"
  />
  <div class="app card" id="app">
    <header>
      <div class="brand">
        <div class="logo"><span>Œº</span></div>
        <h1>Pepsi's Master Quiz</h1>
      </div>
      <div class="scorebar">
        <span class="chip info" id="categoryChip">Loading‚Ä¶</span>
        <span class="chip accent" id="pointsChip">0 / 0 pts</span>
        <span class="chip" id="qpos">Question 0/0</span>
        <span class="chip danger" id="lifes">50/50 √ó 3</span>
      </div>
    </header>

    <!-- START SCREEN -->
    <main id="screenStart">
      <div class="grid">
        <section class="panel">
          <h2>Choose what you want to learn</h2>
          <div class="flex" style="margin-bottom:10px">
            <button class="btn ghost" id="selectAll" type="button">Select all</button>
            <button class="btn ghost" id="clearAll" type="button">Clear all</button>
          </div>
          <div class="cats" id="categories"></div>
        </section>

        <aside class="panel">
          <h2>Game settings</h2>

          <!-- Live available-count + quick picks -->
          <div class="row" style="margin-bottom:10px">
            <label>Available in selected categories</label>
            <div class="flex">
              <span class="chip info" id="availableCount">0 available</span>
              <button class="btn secondary" id="btnAll"  type="button" title="Use all available">All</button>
              <button class="btn secondary" id="btn25"  type="button">25</button>
              <button class="btn secondary" id="btn50"  type="button">50</button>
              <button class="btn secondary" id="btn100" type="button">100</button>
            </div>
          </div>

          <!-- Disabled numeric field reflects the current choice -->
          <div class="row" style="margin-bottom:10px">
            <label for="numQuestions">Total questions</label>
            <input id="numQuestions" type="number" min="1" step="1" value="12" disabled />
          </div>

          <div class="row" style="margin-bottom:10px">
            <label>Question order</label>
            <select id="order">
              <option value="mixed" selected>Mixed & shuffled</option>
              <option value="byCategory">Group by category (shuffled within)</option>
            </select>
          </div>
          <div class="sub" id="sourceInfo" style="display: none;">Source: <em>loading‚Ä¶</em></div>
        </aside>
      </div>

      <div class="flex right" style="margin-top:16px">
        <button id="startBtn" class="btn primary" type="button">Start Quiz</button>
      </div>
    </main>

    <!-- QUIZ SCREEN -->
    <main id="screenQuiz" class="hidden">
      <div class="qwrap">
        <div class="qhead">
          <div class="flex">
            <span class="badge" id="catBadge">Category</span>
            <span class="badge" id="modeBadge" title="Select all that apply">Multiple answers</span>
            <span class="badge" id="ptsBadge">+0 pts</span>
          </div>
          <div class="lifelines">
            <button class="btn secondary" id="fiftyBtn" type="button" title="Eliminate some incorrect options (3 uses per run)">50/50</button>
            <span class="chip danger" id="lifeCount">√ó 3 left</span>
          </div>
        </div>

        <div class="progress"><div class="bar" id="bar"></div></div>
        <div id="qnum" class="tag">Question 1</div>
        <div id="qtext" class="question">‚Äî</div>
        <div id="sataNote" class="sata hidden">This question has multiple correct answers ‚Äî <b>select all that apply</b>.</div>

        <div id="answers" class="answers"></div>
        <div id="explain" class="explain hidden"></div>

        <div class="flex right">
          <button class="btn secondary" id="skipBtn" type="button" title="Skip this question (no points)">Skip</button>
          <button class="btn primary" id="nextBtn" type="button" disabled>Next</button>
        </div>
        <div class="tag">Keyboard: numbers to select ‚Ä¢ <kbd>F</kbd> 50/50 ‚Ä¢ <kbd>Enter</kbd>/<kbd>N</kbd> check/next</div>
      </div>
    </main>

    <!-- RESULT SCREEN -->
    <main id="screenResult" class="hidden">
      <div class="result">
        <h2 class="big" id="winTitle">Well done!</h2>
        <p id="summary"></p>
        <div class="flex" style="justify-content:center; gap:16px">
          <span class="chip accent" id="finalScore">0 pts</span>
          <span class="chip" id="accuracy">Score: 0%</span>
          <span class="chip info" id="catsPlayed">‚Äî</span>
        </div>
        <div class="flex" style="justify-content:center; gap:10px; margin-top:12px">
          <button class="btn secondary" id="reviewBtn" type="button">Review answers</button>
          <button class="btn primary" id="restartBtn" type="button">Play again</button>
        </div>
        <div id="review" class="panel hidden" style="text-align:left"></div>
      </div>
    </main>
  </div>
  <script>
    (function () {
      const img = document.getElementById('flaus');

      // Add or remove animations here; class names must match CSS above.
      const animations = [
        'anim-shake',
        'anim-jump',
        'anim-flip-x',
        'anim-flip-y',
        'anim-spin',
        'anim-wobble',
        'anim-bounce',
        'anim-swing',
        'anim-pulse',
        'anim-rubber',
        'anim-tada',
        'anim-jello',
        'anim-zoom'
      ];

      // Optional: tweak duration randomly a bit each click for variety.
      function randomizeDuration() {
        // Between 600ms and 1100ms
        const ms = Math.floor(600 + Math.random() * 500);
        document.documentElement.style.setProperty('--anim-duration', ms + 'ms');
      }

      // Helper to restart an animation reliably
      function playRandomAnimation() {
        randomizeDuration();

        // Pick a random animation
        const next = animations[Math.floor(Math.random() * animations.length)];

        // Remove any existing animation classes
        img.classList.add('animating');
        animations.forEach(a => img.classList.remove(a));

        // Force reflow so the browser recognizes re-adding the class
        // eslint-disable-next-line no-unused-expressions
        void img.offsetWidth;

        // Add the new one
        img.classList.add(next);
      }

      // Clean up after animation ends
      img.addEventListener('animationend', () => {
        animations.forEach(a => img.classList.remove(a));
        img.classList.remove('animating');
      });

      // Click / keyboard activation
      img.addEventListener('click', playRandomAnimation);
      img.setAttribute('tabindex', '0');
      img.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          playRandomAnimation();
        }
      });

      // Bonus: little attention pulse on first load
      setTimeout(() => {
        img.classList.add('anim-pulse');
      }, 300);
      img.addEventListener('animationend', (e) => {
        if (e.animationName === 'pulse') {
          img.classList.remove('anim-pulse');
        }
      });
    })();
  </script>
<script>
/*
  =========================
  DATA SOURCES
  =========================
  Prefers inline JS sets (questions.js, questions2.js). Falls back to JSON via:
    quiz.html?data=questions.json,more.json
*/

// ---------- Helpers ----------
const $ = id => document.getElementById(id);
const screenStart = $('screenStart');
const screenQuiz  = $('screenQuiz');
const screenResult= $('screenResult');
const categoriesEl= $('categories');
const selectAllBtn= $('selectAll');
const clearAllBtn = $('clearAll');
const startBtn    = $('startBtn');
const orderSel    = $('order');
const numQuestions= $('numQuestions');
const pointsChip  = $('pointsChip');
const categoryChip= $('categoryChip');
const qposChip    = $('qpos');
const lifesChip   = $('lifes');
const sourceInfo  = $('sourceInfo');

// Quiz controls
const bar         = $('bar');
const qnum        = $('qnum');
const qtext       = $('qtext');
const sataNote    = $('sataNote');
const answers     = $('answers');
const explain     = $('explain');
const nextBtn     = $('nextBtn');
const skipBtn     = $('skipBtn');
const fiftyBtn    = $('fiftyBtn');
const lifeCount   = $('lifeCount');
const catBadge    = $('catBadge');
const modeBadge   = $('modeBadge');
const ptsBadge    = $('ptsBadge');

// Result
const winTitle    = $('winTitle');
const finalScore  = $('finalScore');
const accuracy    = $('accuracy');
const catsPlayed  = $('catsPlayed');
const reviewBtn   = $('reviewBtn');
const restartBtn  = $('restartBtn');
const reviewBox   = $('review');

// Availability + quick picks
const availableCountEl = $('availableCount');
const btnAll  = $('btnAll');
const btn25   = $('btn25');
const btn50   = $('btn50');
const btn100  = $('btn100');

// Config: sources from URL (?data=a.json,b.json) or default
function getSourcesFromQuery(){
  const u = new URL(location.href);
  const val = u.searchParams.get('data');
  if(!val) return null;
  return val.split(',').map(s=>s.trim()).filter(Boolean);
}
const CONFIG = { sources: getSourcesFromQuery() || ['questions.json'] };

// Sample fallback (only used if everything fails)
const sampleData = [
  {category:"Spectroscopy ‚Äì IR", question:"Beer‚ÄìLambert: $A=\\varepsilon l c$ or <math><mi>A</mi><mo>=</mo><mi>Œµ</mi><mi>l</mi><mi>c</mi></math>.", choices:["$\\alpha$","<math><mi>\\mu</mi></math>","dipole moment $\\mu$","index of refraction"], correctIndex:2, points:10, explanation:"IR selection rule: change in dipole moment."}
];

// ---------- State ----------
let allQuestions = [];
let selectedQuestions = [];
let selectionCategories = new Set();
let orderMode = 'mixed';
let idx = 0; // current question index
let points = 0;
let total = 0;
let maxPointsTotal = 0;
let lifelines = 3; // 3√ó 50/50 per run
let history = []; // for review
let currentIsMulti = false;
let checked = false; // whether current question has been checked
let multiSelection = new Set();
let locked = false; // prevent double evaluation for single-choice

// Formatting helpers
const clamp = (x,min,max)=>Math.max(min,Math.min(max,x));
const r1 = x => Math.round(x*10)/10; // round to 0.1
const fmtPts = x => (Math.abs(x - Math.round(x)) < 1e-9 ? String(Math.round(x)) : x.toFixed(1));

// ---------- Data loading & normalization ----------
async function fetchArray(url){
  const res = await fetch(url, {cache:'no-store'});
  if(!res.ok) throw new Error(res.status+" "+res.statusText);
  const data = await res.json();
  if(Array.isArray(data)) return data; // array root
  if(Array.isArray(data.questions)) return data.questions; // {questions:[...]}
  throw new Error('JSON must be an array or {questions:[‚Ä¶]}');
}

function normalizeQuestion(q, i){
  if(typeof q.category!== 'string' || typeof q.question!== 'string' || !Array.isArray(q.choices)){
    throw new Error('Invalid question at index '+i);
  }
  let correctIndices = [];
  if(Array.isArray(q.correctIndices)){
    correctIndices = q.correctIndices.slice();
  } else if(typeof q.correctIndex === 'number'){
    correctIndices = [q.correctIndex];
  } else {
    throw new Error('Missing correctIndex/correctIndices at index '+i);
  }
  correctIndices = correctIndices.filter(n => Number.isInteger(n) && n>=0 && n<q.choices.length);
  if(correctIndices.length === 0) throw new Error('No valid correct indices at index '+i);

  return {
    category: q.category,
    question: q.question,
    choices: q.choices,
    correctIndices,
    points: typeof q.points==='number'? q.points : 10,
    explanation: q.explanation||''
  };
}

async function loadAllSources(){
  // Prefer inline JS sets
  if (Array.isArray(window.__QUIZ_SETS__) && window.__QUIZ_SETS__.length > 0) {
    const merged = window.__QUIZ_SETS__.flat();
    allQuestions = merged.map(normalizeQuestion);
    const names = Array.isArray(window.__QUIZ_SET_NAMES__) && window.__QUIZ_SET_NAMES__.length
      ? window.__QUIZ_SET_NAMES__.join(', ')
      : 'inline scripts';
    sourceInfo.innerHTML = 'Source: <em>' + names + '</em>';
    return;
  }

  // Otherwise, try JSON from query or default
  sourceInfo.innerHTML = 'Source: <em>'+CONFIG.sources.join(', ')+'</em>';
  try{
    const arrays = await Promise.all(CONFIG.sources.map(fetchArray));
    const merged = arrays.flat();
    allQuestions = merged.map(normalizeQuestion);
  }catch(err){
    console.warn('Falling back to sample data due to:', err);
    allQuestions = sampleData.map(normalizeQuestion);
    sourceInfo.innerHTML = 'Source: <em>embedded sample (fetch failed)</em>';
  }
}

function uniqueCategories(data){
  return [...new Set(data.map(q => q.category))].sort();
}

function renderCategories(){
  const cats = uniqueCategories(allQuestions);
  categoriesEl.innerHTML = '';
  cats.forEach(cat => {
    const id = 'cat_'+cat.replace(/[^A-Za-z0-9_]+/g,'_');
    const div = document.createElement('label');
    div.className = 'cat';
    div.innerHTML = `<input type="checkbox" id="${id}" data-cat="${cat}" checked> <span>${cat}</span>`;
    categoriesEl.appendChild(div);
  });
  selectionCategories = new Set(cats);
  updateCatChip();
  syncAvailableUI(); // initial totals
}

function updateCatChip(){
  const list = [...selectionCategories];
  categoryChip.textContent = list.length? `${list.length} cat${list.length>1?'egories':''} selected` : 'No categories selected';
}

function attachCategoryHandlers(){
  categoriesEl.addEventListener('change', (e)=>{
    const cb = e.target.closest('input[type="checkbox"]');
    if(!cb) return;
    const cat = cb.getAttribute('data-cat');
    if(cb.checked) selectionCategories.add(cat); else selectionCategories.delete(cat);
    updateCatChip();
    syncAvailableUI(); // update totals on change
  });
}

// ----- Availability + quick-picks -----
function getAvailablePool() {
  const chosen = [...selectionCategories];
  return allQuestions.filter(q => chosen.includes(q.category));
}

function syncAvailableUI({keepCustom=false} = {}) {
  const pool = getAvailablePool();
  const count = pool.length;
  availableCountEl.textContent = `${count} available`;
  if (!keepCustom) {
    numQuestions.value = count; // auto-set to ALL
  }
  startBtn.disabled = (count === 0);
}

function setCountTo(n) {
  const poolSize = getAvailablePool().length;
  numQuestions.value = Math.min(n, poolSize);
}
btnAll.addEventListener('click', () => setCountTo(getAvailablePool().length));
btn25.addEventListener('click', () => setCountTo(25));
btn50.addEventListener('click', () => setCountTo(50));
btn100.addEventListener('click', () => setCountTo(100));

// ----- Progress & building -----
function setProgress(i, total){
  const pct = Math.round((i/Math.max(1,total))*100);
  bar.style.width = pct + '%';
  qposChip.textContent = `Question ${Math.min(i+1,total)}/${total}`;
}

function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
  return arr;
}

function buildSelection(){
  const chosenCats = [...selectionCategories];
  let pool = allQuestions.filter(q => chosenCats.includes(q.category));
  if(orderMode === 'byCategory'){
    const groups = {};
    chosenCats.forEach(c=> groups[c] = []);
    pool.forEach(q => groups[q.category].push(q));
    Object.values(groups).forEach(g=>shuffle(g));
    pool = chosenCats.flatMap(c => groups[c]);
  } else {
    shuffle(pool);
  }
  const n = Math.min(parseInt(numQuestions.value||10,10), pool.length);
  // Deep-ish copy per question to allow per-question shuffling without touching originals
  selectedQuestions = pool.slice(0, n).map(q => ({
    ...q,
    choices: [...q.choices],
    correctIndices: [...q.correctIndices],
    _shuffled: false
  }));
  total = selectedQuestions.length;
  maxPointsTotal = selectedQuestions.reduce((s,q)=>s+q.points,0);
  updateTotalPointsChip();
}

// ----- MathJax typesetting -----
function typeset(element){
  if (window.MathJax && window.MathJax.typesetPromise) {
    MathJax.typesetPromise([element]).catch(()=>{});
  }
}

// ----- Score chip updater -----
function updateTotalPointsChip(){
  pointsChip.textContent = `${fmtPts(points)} / ${fmtPts(maxPointsTotal)} pts`;
}

// ----- Game flow -----
function startGame(){
  if(selectionCategories.size === 0){ alert('Pick at least one category.'); return; }
  buildSelection();
  if(total === 0){ alert('No questions available for the selected categories.'); return; }
  points = 0; idx = 0; lifelines = 3; history = []; checked = false; multiSelection.clear();
  screenStart.classList.add('hidden');
  screenResult.classList.add('hidden');
  screenQuiz.classList.remove('hidden');
  lifesChip.textContent = `50/50 √ó ${lifelines}`;
  lifeCount.textContent = `√ó ${lifelines} left`;
  updateTotalPointsChip();
  renderQuestion();
}

function shuffleChoicesInPlace(q){
  if (q._shuffled) return q;
  const n = q.choices.length;
  const order = [...Array(n).keys()];
  shuffle(order);
  const newChoices = order.map(i => q.choices[i]);
  const correctSetOrig = new Set(q.correctIndices);
  const newCorrect = [];
  for (let j=0; j<n; j++){
    const origIdx = order[j];
    if (correctSetOrig.has(origIdx)) newCorrect.push(j);
  }
  q.choices = newChoices;
  q.correctIndices = newCorrect;
  q._shuffled = true;
  return q;
}

function renderQuestion(){
  locked = false; // ensure we can pick again
  let q = selectedQuestions[idx];
  q = shuffleChoicesInPlace(q); // shuffle options once per question (keeps indices consistent)

  currentIsMulti = (q.correctIndices && q.correctIndices.length > 1);
  checked = false; multiSelection.clear();
  setProgress(idx, total);
  qnum.textContent = `Question ${idx+1} of ${total}`;

  // Avoid duplicating "[Select all that apply]" if author already put it in the question text
  const alreadyHasSATA = /\bselect all that apply\b/i.test(q.question);
  qtext.innerHTML = q.question + (currentIsMulti && !alreadyHasSATA
    ? ' <span class="badge" style="margin-left:6px">[Select all that apply]</span>'
    : '');

  sataNote.classList.toggle('hidden', !currentIsMulti);
  answers.innerHTML = '';
  explain.classList.add('hidden'); explain.innerHTML = '';
  nextBtn.disabled = true; nextBtn.textContent = currentIsMulti ? 'Check' : 'Next';
  catBadge.textContent = q.category;
  modeBadge.classList.toggle('hidden', !currentIsMulti);
  ptsBadge.textContent = `+0 pts`;

  const keys = ['1','2','3','4','5','6','7','8','9'];
  q.choices.forEach((choice, i)=>{
    const el = document.createElement('label');
    el.className = 'opt';
    const type = currentIsMulti ? 'checkbox' : 'radio';
    el.innerHTML = `<input type="${type}" name="ans" value="${i}"><span class="key">${keys[i]||i+1}</span> <span class="txt">${choice}</span>`;
    answers.appendChild(el);
  });

  // Robust click handling: delegate per-question
  answers.onclick = (e) => {
    const opt = e.target.closest('.opt');
    if (!opt) return;
    const input = opt.querySelector('input');
    if (!input || input.disabled) return;

    if (currentIsMulti) {
      input.checked = !input.checked;
      input.dispatchEvent(new Event('change', {bubbles:true}));
    } else {
      if (!input.checked) input.checked = true;
      if(!locked) checkSingle([...answers.querySelectorAll('.opt')].indexOf(opt));
    }
  };

  // Change handler for multi-select
  answers.onchange = (e)=>{
    if (!currentIsMulti) return;
    const input = e.target.closest('input[type="checkbox"]');
    if (!input || input.disabled) return;
    const opt = input.closest('.opt');
    const items = [...answers.querySelectorAll('.opt')];
    const i = items.indexOf(opt);
    if (i < 0) return;
    if (input.checked) {
      multiSelection.add(i);
      opt.classList.add('picked');
    } else {
      multiSelection.delete(i);
      opt.classList.remove('picked');
    }
    nextBtn.disabled = (multiSelection.size === 0);
  };

  // 50/50 availability: disabled on multi-answer or when no lives left
  fiftyBtn.disabled = currentIsMulti || lifelines <= 0;
  fiftyBtn.title = currentIsMulti
    ? 'Disabled for multiple-answer questions'
    : (lifelines > 0 ? 'Eliminate two incorrect options (3 uses per run)' : 'No 50/50 left');

  // Typeset math in question and choices (TeX and/or MathML)
  typeset(qtext);
  typeset(answers);
}

function disableCurrentInputs(){
  answers.onclick = null;
  answers.onchange = null;
  answers.querySelectorAll('input').forEach(inp => inp.disabled = true);
}

function checkSingle(i){
  locked = true; checked = true;
  const q = selectedQuestions[idx];
  const correct = q.correctIndices[0];
  const opts = [...answers.querySelectorAll('.opt')];

  // Feedback classes
  opts.forEach((opt, j)=>{
    if(j === correct) opt.classList.add('correct');
    if(j === i && i !== correct) opt.classList.add('wrong');
  });

  const isRight = i === correct;
  const earned = isRight ? q.points : 0;
  points += earned;
  ptsBadge.textContent = `+${fmtPts(earned)} pts`;
  updateTotalPointsChip();
  setProgress(idx+1, total);
  if(q.explanation){ explain.innerHTML = q.explanation; explain.classList.remove('hidden'); typeset(explain); }
  nextBtn.disabled = false;

  // Lock inputs so points can't change afterwards
  disableCurrentInputs();

  history.push({ idx, category:q.category, question:q.question, choices:q.choices, correctIndices:q.correctIndices, picked:i, pointsEarned: earned, explanation:q.explanation||'' });
}

function checkMulti(){
  if(checked) return;
  checked = true;

  const q = selectedQuestions[idx];
  const correctSet = new Set(q.correctIndices);
  const pickedSet = new Set([...multiSelection]);

  const opts = [...answers.querySelectorAll('.opt')];

  // Mark visuals (picked/wrong, missed correct)
  opts.forEach((opt, j)=>{
    const picked = pickedSet.has(j);
    const correct = correctSet.has(j);
    if (picked && correct) {
      opt.classList.add('correct');
    } else if (picked && !correct) {
      opt.classList.add('wrong');
    } else if (!picked && correct) {
      opt.classList.add('correct','missed');
    }
  });

  // ----- Partial credit -----
  const c = correctSet.size;
  const hits = [...pickedSet].filter(i => correctSet.has(i)).length;
  const falsePos = [...pickedSet].filter(i => !correctSet.has(i)).length;
  const share = q.points / c;
  let earned = share * (hits - falsePos);               // reward hits, penalize wrong picks
  earned = clamp( r1(earned), 0, q.points );            // round to 0.1, clamp to [0, max]
  points += earned;

  ptsBadge.textContent = `+${fmtPts(earned)} pts`;
  updateTotalPointsChip();
  setProgress(idx+1, total);

  if(q.explanation){ explain.innerHTML = q.explanation; explain.classList.remove('hidden'); typeset(explain); }
  nextBtn.disabled = false; nextBtn.textContent = 'Next';

  // Lock inputs so points can't change afterwards
  disableCurrentInputs();

  history.push({ idx, category:q.category, question:q.question, choices:q.choices, correctIndices:q.correctIndices, picked:[...pickedSet], pointsEarned: earned, explanation:q.explanation||'' });
}

function apply5050(){
  // Not available on multi-answer questions
  if (currentIsMulti) return;
  if (lifelines <= 0) return;

  const q = selectedQuestions[idx];
  const correctSet = new Set(q.correctIndices);
  const opts = [...answers.querySelectorAll('.opt')];

  // Consider only currently visible wrong options
  const visibleWrongs = opts
    .map((el,i)=>({el,i}))
    .filter(o => !o.el.classList.contains('hidden') && !correctSet.has(o.i));

  if (visibleWrongs.length === 0) return;

  shuffle(visibleWrongs);
  const toHideCount = Math.min(2, visibleWrongs.length);  // hide exactly 2 wrong answers when possible
  visibleWrongs.slice(0, toHideCount).forEach(o => o.el.classList.add('hidden'));

  lifelines--;
  lifesChip.textContent = `50/50 √ó ${lifelines}`;
  lifeCount.textContent = `√ó ${lifelines} left`;
  fiftyBtn.disabled = true;
  fiftyBtn.title = lifelines > 0 ? 'Eliminate two incorrect options (3 uses per run)' : 'No 50/50 left';
}

function nextQuestion(){
  locked = false; checked = false; multiSelection.clear();
  idx++;
  if(idx >= total){ endGame(); } else { renderQuestion(); }
}

function skipQuestion(){
  if(checked) return;
  const q = selectedQuestions[idx];
  history.push({ idx, category:q.category, question:q.question, choices:q.choices, correctIndices:q.correctIndices, picked:null, pointsEarned:0, explanation:q.explanation||'' });
  setProgress(idx+1, total);
  nextQuestion();
}

function endGame(){
  screenQuiz.classList.add('hidden');
  screenResult.classList.remove('hidden');

  // Final numbers
  finalScore.textContent = `${fmtPts(points)} / ${fmtPts(maxPointsTotal)} pts`;
  const pointsPct = maxPointsTotal ? Math.round((points / maxPointsTotal)*100) : 0;

  // Also show perfect-question count
  const perfects = history.filter(h=>{
    if(Array.isArray(h.picked)){
      const setP = new Set(h.picked||[]);
      const setC = new Set(h.correctIndices||[]);
      return setP.size===setC.size && [...setC].every(v=>setP.has(v));
    }
    return h.picked=== (h.correctIndices? h.correctIndices[0]: -1);
  }).length;

  accuracy.textContent = `Score: ${pointsPct}% ‚Ä¢ Perfect: ${perfects}/${total}`;
  const cats = [...new Set(history.map(h=> selectedQuestions[h.idx]?.category || h.category))];
  catsPlayed.textContent = cats.join(' ‚Ä¢ ');

  let title = 'Well done!';
  if(pointsPct === 100) title = 'Absolute Unit! üß™‚ú®';
  else if(pointsPct >= 85) title = 'Distinction-level performance!';
  else if(pointsPct >= 70) title = 'Strong pass!';
  else if(pointsPct >= 50) title = 'Keep going ‚Äî solid effort!';
  else title = 'Good start ‚Äî review & retry!';
  winTitle.textContent = title;

  const frag = document.createDocumentFragment();
  history.forEach((h, n)=>{
    const wrap = document.createElement('div');
    wrap.className = 'panel';
    const q = selectedQuestions[h.idx] || h;
    const correctSet = new Set(q.correctIndices||[]);
    const pickedSet  = new Set(Array.isArray(h.picked)? h.picked : (h.picked==null? [] : [h.picked]));
    let html = `<div class="tag">Q${n+1} ‚Ä¢ <b>${q.category}</b>${(q.correctIndices||[]).length>1? ' ‚Ä¢ multiple answers':''} ‚Ä¢ Earned: ${fmtPts(h.pointsEarned)} / ${fmtPts(q.points)} pts</div>`;
    html += `<div class="question" style="font-size:18px">${q.question}</div>`;
    html += '<div class="answers" style="margin-top:8px">';
    q.choices.forEach((c, i)=>{
      const cls = correctSet.has(i) ? (pickedSet.has(i) ? 'correct' : 'correct missed')
               : (pickedSet.has(i) ? 'wrong' : '');
      html += `<div class="opt ${cls}" style="cursor:default"><span class="key">${i+1}</span> <span>${c}</span></div>`;
    });
    html += '</div>';
    if(q.explanation){ html += `<div class="explain" style="margin-top:8px">${q.explanation}</div>`; }
    wrap.innerHTML = html;
    frag.appendChild(wrap);
  });
  reviewBox.innerHTML = '';
  reviewBox.appendChild(frag);
  typeset(reviewBox);
}

// Keyboard shortcuts
window.addEventListener('keydown', (e)=>{
  if(screenQuiz.classList.contains('hidden')) return;
  const opts = [...answers.querySelectorAll('.opt')];
  if(/^[1-9]$/.test(e.key)){
    const i = parseInt(e.key,10)-1;
    if(opts[i]){
      if(currentIsMulti){
        const input = opts[i].querySelector('input[type="checkbox"]');
        if (input && !input.disabled) {
          input.checked = !input.checked;
          input.dispatchEvent(new Event('change', {bubbles:true}));
        }
      } else {
        if(!locked) checkSingle(i);
      }
    }
  } else if(e.key.toLowerCase()==='f'){
    if(!fiftyBtn.disabled && lifelines>0) apply5050();
  } else if(e.key.toLowerCase()==='n' || e.key === 'Enter'){
    if(!checked && currentIsMulti && !nextBtn.disabled){
      checkMulti();
    } else if(!nextBtn.disabled){
      nextQuestion();
    }
  }
});

// Wire up controls
selectAllBtn.addEventListener('click', ()=>{
  categoriesEl.querySelectorAll('input[type="checkbox"]').forEach(cb=>cb.checked=true);
  selectionCategories = new Set(uniqueCategories(allQuestions));
  updateCatChip();
  syncAvailableUI();
});
clearAllBtn.addEventListener('click', ()=>{
  categoriesEl.querySelectorAll('input[type="checkbox"]').forEach(cb=>cb.checked=false);
  selectionCategories.clear();
  updateCatChip();
  syncAvailableUI();
});
orderSel.addEventListener('change', ()=>{ orderMode = orderSel.value; });
startBtn.addEventListener('click', startGame);
nextBtn.addEventListener('click', ()=>{
  if(currentIsMulti && !checked){ checkMulti(); } else { nextQuestion(); }
});
skipBtn.addEventListener('click', skipQuestion);
reviewBtn.addEventListener('click', ()=> reviewBox.classList.toggle('hidden'));
restartBtn.addEventListener('click', ()=>{ screenResult.classList.add('hidden'); screenStart.classList.remove('hidden'); });
fiftyBtn.addEventListener('click', apply5050); // ‚Üê Hook up the 50/50 button

// Init
(async function init(){
  await loadAllSources();
  renderCategories();
  attachCategoryHandlers();
  pointsChip.textContent = '0 / 0 pts';
  qposChip.textContent = 'Question 0/0';
  lifesChip.textContent = '50/50 √ó 3';
  syncAvailableUI();
})();
</script>

</body>
</html>
